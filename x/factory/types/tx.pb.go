// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zigchain/factory/tx.proto

package types

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types1 "github.com/cosmos/cosmos-sdk/x/bank/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless
	// overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgCreateDenom used to create new denom via factory
type MsgCreateDenom struct {
	Creator             string                 `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SubDenom            string                 `protobuf:"bytes,2,opt,name=sub_denom,json=subDenom,proto3" json:"sub_denom,omitempty"`
	MintingCap          cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=minting_cap,json=mintingCap,proto3,customtype=cosmossdk.io/math.Uint" json:"minting_cap"`
	CanChangeMintingCap bool                   `protobuf:"varint,4,opt,name=can_change_minting_cap,json=canChangeMintingCap,proto3" json:"can_change_minting_cap,omitempty"`
	// metadata
	URI string `protobuf:"bytes,5,opt,name=URI,proto3" json:"URI,omitempty"`
	// sha256 hash of the JSON metadata file
	URIHash     string `protobuf:"bytes,6,opt,name=URI_hash,json=URIHash,proto3" json:"URI_hash,omitempty"`
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *MsgCreateDenom) Reset()         { *m = MsgCreateDenom{} }
func (m *MsgCreateDenom) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDenom) ProtoMessage()    {}
func (*MsgCreateDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{2}
}
func (m *MsgCreateDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDenom.Merge(m, src)
}
func (m *MsgCreateDenom) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDenom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDenom proto.InternalMessageInfo

func (m *MsgCreateDenom) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateDenom) GetSubDenom() string {
	if m != nil {
		return m.SubDenom
	}
	return ""
}

func (m *MsgCreateDenom) GetCanChangeMintingCap() bool {
	if m != nil {
		return m.CanChangeMintingCap
	}
	return false
}

func (m *MsgCreateDenom) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *MsgCreateDenom) GetURIHash() string {
	if m != nil {
		return m.URIHash
	}
	return ""
}

func (m *MsgCreateDenom) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// MsgCreateDenomResponse is conformation on created denom.
type MsgCreateDenomResponse struct {
	Creator             string                 `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	BankAdmin           string                 `protobuf:"bytes,2,opt,name=bank_admin,json=bankAdmin,proto3" json:"bank_admin,omitempty"`
	MetadataAdmin       string                 `protobuf:"bytes,3,opt,name=metadata_admin,json=metadataAdmin,proto3" json:"metadata_admin,omitempty"`
	Denom               string                 `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty"`
	MintingCap          cosmossdk_io_math.Uint `protobuf:"bytes,5,opt,name=minting_cap,json=mintingCap,proto3,customtype=cosmossdk.io/math.Uint" json:"minting_cap"`
	CanChangeMintingCap bool                   `protobuf:"varint,6,opt,name=can_change_minting_cap,json=canChangeMintingCap,proto3" json:"can_change_minting_cap,omitempty"`
	URI                 string                 `protobuf:"bytes,7,opt,name=URI,proto3" json:"URI,omitempty"`
	URIHash             string                 `protobuf:"bytes,8,opt,name=URI_hash,json=URIHash,proto3" json:"URI_hash,omitempty"`
}

func (m *MsgCreateDenomResponse) Reset()         { *m = MsgCreateDenomResponse{} }
func (m *MsgCreateDenomResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDenomResponse) ProtoMessage()    {}
func (*MsgCreateDenomResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{3}
}
func (m *MsgCreateDenomResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDenomResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDenomResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDenomResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDenomResponse.Merge(m, src)
}
func (m *MsgCreateDenomResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDenomResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDenomResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDenomResponse proto.InternalMessageInfo

func (m *MsgCreateDenomResponse) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateDenomResponse) GetBankAdmin() string {
	if m != nil {
		return m.BankAdmin
	}
	return ""
}

func (m *MsgCreateDenomResponse) GetMetadataAdmin() string {
	if m != nil {
		return m.MetadataAdmin
	}
	return ""
}

func (m *MsgCreateDenomResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgCreateDenomResponse) GetCanChangeMintingCap() bool {
	if m != nil {
		return m.CanChangeMintingCap
	}
	return false
}

func (m *MsgCreateDenomResponse) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *MsgCreateDenomResponse) GetURIHash() string {
	if m != nil {
		return m.URIHash
	}
	return ""
}

// MsgMintAndSendTokens mints tokens and sends them to a recipient
type MsgMintAndSendTokens struct {
	Signer    string     `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Token     types.Coin `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Recipient string     `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
}

func (m *MsgMintAndSendTokens) Reset()         { *m = MsgMintAndSendTokens{} }
func (m *MsgMintAndSendTokens) String() string { return proto.CompactTextString(m) }
func (*MsgMintAndSendTokens) ProtoMessage()    {}
func (*MsgMintAndSendTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{4}
}
func (m *MsgMintAndSendTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintAndSendTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintAndSendTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintAndSendTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintAndSendTokens.Merge(m, src)
}
func (m *MsgMintAndSendTokens) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintAndSendTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintAndSendTokens.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintAndSendTokens proto.InternalMessageInfo

func (m *MsgMintAndSendTokens) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgMintAndSendTokens) GetToken() types.Coin {
	if m != nil {
		return m.Token
	}
	return types.Coin{}
}

func (m *MsgMintAndSendTokens) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

// MsgMintAndSendTokensResponse is conformation on minted and sent tokens.
type MsgMintAndSendTokensResponse struct {
	TokenMinted *types.Coin `protobuf:"bytes,1,opt,name=token_minted,json=tokenMinted,proto3" json:"token_minted,omitempty"`
	Recipient   string      `protobuf:"bytes,2,opt,name=recipient,proto3" json:"recipient,omitempty"`
	TotalMinted *types.Coin `protobuf:"bytes,3,opt,name=total_minted,json=totalMinted,proto3" json:"total_minted,omitempty"`
	TotalSupply *types.Coin `protobuf:"bytes,4,opt,name=total_supply,json=totalSupply,proto3" json:"total_supply,omitempty"`
}

func (m *MsgMintAndSendTokensResponse) Reset()         { *m = MsgMintAndSendTokensResponse{} }
func (m *MsgMintAndSendTokensResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintAndSendTokensResponse) ProtoMessage()    {}
func (*MsgMintAndSendTokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{5}
}
func (m *MsgMintAndSendTokensResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintAndSendTokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintAndSendTokensResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintAndSendTokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintAndSendTokensResponse.Merge(m, src)
}
func (m *MsgMintAndSendTokensResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintAndSendTokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintAndSendTokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintAndSendTokensResponse proto.InternalMessageInfo

func (m *MsgMintAndSendTokensResponse) GetTokenMinted() *types.Coin {
	if m != nil {
		return m.TokenMinted
	}
	return nil
}

func (m *MsgMintAndSendTokensResponse) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgMintAndSendTokensResponse) GetTotalMinted() *types.Coin {
	if m != nil {
		return m.TotalMinted
	}
	return nil
}

func (m *MsgMintAndSendTokensResponse) GetTotalSupply() *types.Coin {
	if m != nil {
		return m.TotalSupply
	}
	return nil
}

// MsgUpdateDenomURI updates the URI of a denom and its sha256 hash
type MsgUpdateDenomURI struct {
	Signer  string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom   string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	URI     string `protobuf:"bytes,3,opt,name=URI,proto3" json:"URI,omitempty"`
	URIHash string `protobuf:"bytes,4,opt,name=URI_hash,json=URIHash,proto3" json:"URI_hash,omitempty"`
}

func (m *MsgUpdateDenomURI) Reset()         { *m = MsgUpdateDenomURI{} }
func (m *MsgUpdateDenomURI) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomURI) ProtoMessage()    {}
func (*MsgUpdateDenomURI) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{6}
}
func (m *MsgUpdateDenomURI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomURI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomURI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomURI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomURI.Merge(m, src)
}
func (m *MsgUpdateDenomURI) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomURI) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomURI.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomURI proto.InternalMessageInfo

func (m *MsgUpdateDenomURI) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgUpdateDenomURI) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomURI) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *MsgUpdateDenomURI) GetURIHash() string {
	if m != nil {
		return m.URIHash
	}
	return ""
}

// MsgUpdateDenomURIResponse is conformation on updated metadata.
type MsgUpdateDenomURIResponse struct {
	Denom   string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	URI     string `protobuf:"bytes,2,opt,name=URI,proto3" json:"URI,omitempty"`
	URIHash string `protobuf:"bytes,3,opt,name=URI_hash,json=URIHash,proto3" json:"URI_hash,omitempty"`
}

func (m *MsgUpdateDenomURIResponse) Reset()         { *m = MsgUpdateDenomURIResponse{} }
func (m *MsgUpdateDenomURIResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomURIResponse) ProtoMessage()    {}
func (*MsgUpdateDenomURIResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{7}
}
func (m *MsgUpdateDenomURIResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomURIResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomURIResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomURIResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomURIResponse.Merge(m, src)
}
func (m *MsgUpdateDenomURIResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomURIResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomURIResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomURIResponse proto.InternalMessageInfo

func (m *MsgUpdateDenomURIResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomURIResponse) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *MsgUpdateDenomURIResponse) GetURIHash() string {
	if m != nil {
		return m.URIHash
	}
	return ""
}

// MsgUpdateDenomMintingCap updates the minting cap and options o lock
// minting cap changes on a denom
type MsgUpdateDenomMintingCap struct {
	Signer              string                 `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom               string                 `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MintingCap          cosmossdk_io_math.Uint `protobuf:"bytes,3,opt,name=minting_cap,json=mintingCap,proto3,customtype=cosmossdk.io/math.Uint" json:"minting_cap"`
	CanChangeMintingCap bool                   `protobuf:"varint,4,opt,name=can_change_minting_cap,json=canChangeMintingCap,proto3" json:"can_change_minting_cap,omitempty"`
}

func (m *MsgUpdateDenomMintingCap) Reset()         { *m = MsgUpdateDenomMintingCap{} }
func (m *MsgUpdateDenomMintingCap) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomMintingCap) ProtoMessage()    {}
func (*MsgUpdateDenomMintingCap) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{8}
}
func (m *MsgUpdateDenomMintingCap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomMintingCap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomMintingCap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomMintingCap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomMintingCap.Merge(m, src)
}
func (m *MsgUpdateDenomMintingCap) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomMintingCap) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomMintingCap.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomMintingCap proto.InternalMessageInfo

func (m *MsgUpdateDenomMintingCap) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgUpdateDenomMintingCap) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomMintingCap) GetCanChangeMintingCap() bool {
	if m != nil {
		return m.CanChangeMintingCap
	}
	return false
}

// MsgUpdateDenomMintingCapResponse is conformation on updated metadata.
type MsgUpdateDenomMintingCapResponse struct {
	Denom               string                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	MintingCap          cosmossdk_io_math.Uint `protobuf:"bytes,2,opt,name=minting_cap,json=mintingCap,proto3,customtype=cosmossdk.io/math.Uint" json:"minting_cap"`
	CanChangeMintingCap bool                   `protobuf:"varint,3,opt,name=can_change_minting_cap,json=canChangeMintingCap,proto3" json:"can_change_minting_cap,omitempty"`
}

func (m *MsgUpdateDenomMintingCapResponse) Reset()         { *m = MsgUpdateDenomMintingCapResponse{} }
func (m *MsgUpdateDenomMintingCapResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomMintingCapResponse) ProtoMessage()    {}
func (*MsgUpdateDenomMintingCapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{9}
}
func (m *MsgUpdateDenomMintingCapResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomMintingCapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomMintingCapResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomMintingCapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomMintingCapResponse.Merge(m, src)
}
func (m *MsgUpdateDenomMintingCapResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomMintingCapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomMintingCapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomMintingCapResponse proto.InternalMessageInfo

func (m *MsgUpdateDenomMintingCapResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomMintingCapResponse) GetCanChangeMintingCap() bool {
	if m != nil {
		return m.CanChangeMintingCap
	}
	return false
}

// MsgUpdateDenomMetadataAuth updates the metadata admin of a denom, needed for
// case when bank admin is disabled
type MsgUpdateDenomMetadataAuth struct {
	Signer        string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom         string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MetadataAdmin string `protobuf:"bytes,3,opt,name=metadata_admin,json=metadataAdmin,proto3" json:"metadata_admin,omitempty"`
}

func (m *MsgUpdateDenomMetadataAuth) Reset()         { *m = MsgUpdateDenomMetadataAuth{} }
func (m *MsgUpdateDenomMetadataAuth) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomMetadataAuth) ProtoMessage()    {}
func (*MsgUpdateDenomMetadataAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{10}
}
func (m *MsgUpdateDenomMetadataAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomMetadataAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomMetadataAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomMetadataAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomMetadataAuth.Merge(m, src)
}
func (m *MsgUpdateDenomMetadataAuth) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomMetadataAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomMetadataAuth.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomMetadataAuth proto.InternalMessageInfo

func (m *MsgUpdateDenomMetadataAuth) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgUpdateDenomMetadataAuth) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomMetadataAuth) GetMetadataAdmin() string {
	if m != nil {
		return m.MetadataAdmin
	}
	return ""
}

// MsgUpdateDenomMetadataAuthResponse is conformation on updated metadata.
type MsgUpdateDenomMetadataAuthResponse struct {
	Denom         string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	MetadataAdmin string `protobuf:"bytes,2,opt,name=metadata_admin,json=metadataAdmin,proto3" json:"metadata_admin,omitempty"`
}

func (m *MsgUpdateDenomMetadataAuthResponse) Reset()         { *m = MsgUpdateDenomMetadataAuthResponse{} }
func (m *MsgUpdateDenomMetadataAuthResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDenomMetadataAuthResponse) ProtoMessage()    {}
func (*MsgUpdateDenomMetadataAuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{11}
}
func (m *MsgUpdateDenomMetadataAuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDenomMetadataAuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDenomMetadataAuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDenomMetadataAuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDenomMetadataAuthResponse.Merge(m, src)
}
func (m *MsgUpdateDenomMetadataAuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDenomMetadataAuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDenomMetadataAuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDenomMetadataAuthResponse proto.InternalMessageInfo

func (m *MsgUpdateDenomMetadataAuthResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateDenomMetadataAuthResponse) GetMetadataAdmin() string {
	if m != nil {
		return m.MetadataAdmin
	}
	return ""
}

// MsgBurnTokens burns tokens from the signer's account, signer has to be bank
// admin to do it.
type MsgBurnTokens struct {
	Signer string     `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Token  types.Coin `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
}

func (m *MsgBurnTokens) Reset()         { *m = MsgBurnTokens{} }
func (m *MsgBurnTokens) String() string { return proto.CompactTextString(m) }
func (*MsgBurnTokens) ProtoMessage()    {}
func (*MsgBurnTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{12}
}
func (m *MsgBurnTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnTokens.Merge(m, src)
}
func (m *MsgBurnTokens) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnTokens.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnTokens proto.InternalMessageInfo

func (m *MsgBurnTokens) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgBurnTokens) GetToken() types.Coin {
	if m != nil {
		return m.Token
	}
	return types.Coin{}
}

// MsgBurnTokensResponse is conformation on burned tokens.
type MsgBurnTokensResponse struct {
	AmountBurned types.Coin `protobuf:"bytes,1,opt,name=amount_burned,json=amountBurned,proto3" json:"amount_burned"`
}

func (m *MsgBurnTokensResponse) Reset()         { *m = MsgBurnTokensResponse{} }
func (m *MsgBurnTokensResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnTokensResponse) ProtoMessage()    {}
func (*MsgBurnTokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{13}
}
func (m *MsgBurnTokensResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnTokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnTokensResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnTokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnTokensResponse.Merge(m, src)
}
func (m *MsgBurnTokensResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnTokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnTokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnTokensResponse proto.InternalMessageInfo

func (m *MsgBurnTokensResponse) GetAmountBurned() types.Coin {
	if m != nil {
		return m.AmountBurned
	}
	return types.Coin{}
}

// REPLACE_TS_CLIENT_FIX_FROM_BODY
// MsgSetDenomMetadata sets the metadata of a token
type MsgSetDenomMetadata struct {
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Uncomment me for ts-client, until better solution is found
	Metadata types1.Metadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata"`
}

func (m *MsgSetDenomMetadata) Reset()         { *m = MsgSetDenomMetadata{} }
func (m *MsgSetDenomMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetDenomMetadata) ProtoMessage()    {}
func (*MsgSetDenomMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{14}
}
func (m *MsgSetDenomMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDenomMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDenomMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDenomMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDenomMetadata.Merge(m, src)
}
func (m *MsgSetDenomMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDenomMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDenomMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDenomMetadata proto.InternalMessageInfo

func (m *MsgSetDenomMetadata) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgSetDenomMetadata) GetMetadata() types1.Metadata {
	if m != nil {
		return m.Metadata
	}
	return types1.Metadata{}
}

// MsgSetDenomMetadataResponse is conformation on updated metadata.
type MsgSetDenomMetadataResponse struct {
	// Uncomment me for ts-client, until better solution is found
	Metadata *types1.Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgSetDenomMetadataResponse) Reset()         { *m = MsgSetDenomMetadataResponse{} }
func (m *MsgSetDenomMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetDenomMetadataResponse) ProtoMessage()    {}
func (*MsgSetDenomMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{15}
}
func (m *MsgSetDenomMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDenomMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDenomMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDenomMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDenomMetadataResponse.Merge(m, src)
}
func (m *MsgSetDenomMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDenomMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDenomMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDenomMetadataResponse proto.InternalMessageInfo

func (m *MsgSetDenomMetadataResponse) GetMetadata() *types1.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// REPLACE_TS_CLIENT_FIX_TO_BODY
type MsgWithdrawModuleFees struct {
	Signer   string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
}

func (m *MsgWithdrawModuleFees) Reset()         { *m = MsgWithdrawModuleFees{} }
func (m *MsgWithdrawModuleFees) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawModuleFees) ProtoMessage()    {}
func (*MsgWithdrawModuleFees) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{16}
}
func (m *MsgWithdrawModuleFees) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawModuleFees) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawModuleFees.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawModuleFees) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawModuleFees.Merge(m, src)
}
func (m *MsgWithdrawModuleFees) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawModuleFees) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawModuleFees.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawModuleFees proto.InternalMessageInfo

func (m *MsgWithdrawModuleFees) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgWithdrawModuleFees) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

type MsgWithdrawModuleFeesResponse struct {
	Signer   string       `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Receiver string       `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Amounts  []types.Coin `protobuf:"bytes,3,rep,name=amounts,proto3" json:"amounts"`
}

func (m *MsgWithdrawModuleFeesResponse) Reset()         { *m = MsgWithdrawModuleFeesResponse{} }
func (m *MsgWithdrawModuleFeesResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawModuleFeesResponse) ProtoMessage()    {}
func (*MsgWithdrawModuleFeesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{17}
}
func (m *MsgWithdrawModuleFeesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawModuleFeesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawModuleFeesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawModuleFeesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawModuleFeesResponse.Merge(m, src)
}
func (m *MsgWithdrawModuleFeesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawModuleFeesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawModuleFeesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawModuleFeesResponse proto.InternalMessageInfo

func (m *MsgWithdrawModuleFeesResponse) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgWithdrawModuleFeesResponse) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *MsgWithdrawModuleFeesResponse) GetAmounts() []types.Coin {
	if m != nil {
		return m.Amounts
	}
	return nil
}

// MsgProposeDenomAdmin represents a message to propose a new denom admin
type MsgProposeDenomAdmin struct {
	Signer        string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom         string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	BankAdmin     string `protobuf:"bytes,3,opt,name=bank_admin,json=bankAdmin,proto3" json:"bank_admin,omitempty"`
	MetadataAdmin string `protobuf:"bytes,4,opt,name=metadata_admin,json=metadataAdmin,proto3" json:"metadata_admin,omitempty"`
}

func (m *MsgProposeDenomAdmin) Reset()         { *m = MsgProposeDenomAdmin{} }
func (m *MsgProposeDenomAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgProposeDenomAdmin) ProtoMessage()    {}
func (*MsgProposeDenomAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{18}
}
func (m *MsgProposeDenomAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeDenomAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeDenomAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeDenomAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeDenomAdmin.Merge(m, src)
}
func (m *MsgProposeDenomAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeDenomAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeDenomAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeDenomAdmin proto.InternalMessageInfo

func (m *MsgProposeDenomAdmin) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgProposeDenomAdmin) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgProposeDenomAdmin) GetBankAdmin() string {
	if m != nil {
		return m.BankAdmin
	}
	return ""
}

func (m *MsgProposeDenomAdmin) GetMetadataAdmin() string {
	if m != nil {
		return m.MetadataAdmin
	}
	return ""
}

type MsgProposeDenomAdminResponse struct {
	Denom         string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	BankAdmin     string `protobuf:"bytes,2,opt,name=bank_admin,json=bankAdmin,proto3" json:"bank_admin,omitempty"`
	MetadataAdmin string `protobuf:"bytes,3,opt,name=metadata_admin,json=metadataAdmin,proto3" json:"metadata_admin,omitempty"`
}

func (m *MsgProposeDenomAdminResponse) Reset()         { *m = MsgProposeDenomAdminResponse{} }
func (m *MsgProposeDenomAdminResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeDenomAdminResponse) ProtoMessage()    {}
func (*MsgProposeDenomAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{19}
}
func (m *MsgProposeDenomAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeDenomAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeDenomAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeDenomAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeDenomAdminResponse.Merge(m, src)
}
func (m *MsgProposeDenomAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeDenomAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeDenomAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeDenomAdminResponse proto.InternalMessageInfo

func (m *MsgProposeDenomAdminResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgProposeDenomAdminResponse) GetBankAdmin() string {
	if m != nil {
		return m.BankAdmin
	}
	return ""
}

func (m *MsgProposeDenomAdminResponse) GetMetadataAdmin() string {
	if m != nil {
		return m.MetadataAdmin
	}
	return ""
}

// MsgClaimDenomAdmin represents a message to claim the denom admin role
type MsgClaimDenomAdmin struct {
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom  string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgClaimDenomAdmin) Reset()         { *m = MsgClaimDenomAdmin{} }
func (m *MsgClaimDenomAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgClaimDenomAdmin) ProtoMessage()    {}
func (*MsgClaimDenomAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{20}
}
func (m *MsgClaimDenomAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimDenomAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimDenomAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimDenomAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimDenomAdmin.Merge(m, src)
}
func (m *MsgClaimDenomAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimDenomAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimDenomAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimDenomAdmin proto.InternalMessageInfo

func (m *MsgClaimDenomAdmin) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgClaimDenomAdmin) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgClaimDenomAdminResponse struct {
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgClaimDenomAdminResponse) Reset()         { *m = MsgClaimDenomAdminResponse{} }
func (m *MsgClaimDenomAdminResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimDenomAdminResponse) ProtoMessage()    {}
func (*MsgClaimDenomAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{21}
}
func (m *MsgClaimDenomAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimDenomAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimDenomAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimDenomAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimDenomAdminResponse.Merge(m, src)
}
func (m *MsgClaimDenomAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimDenomAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimDenomAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimDenomAdminResponse proto.InternalMessageInfo

func (m *MsgClaimDenomAdminResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

// MsgDisableDenomAdmin represents a message to disable the denom admin role
type MsgDisableDenomAdmin struct {
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	Denom  string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgDisableDenomAdmin) Reset()         { *m = MsgDisableDenomAdmin{} }
func (m *MsgDisableDenomAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgDisableDenomAdmin) ProtoMessage()    {}
func (*MsgDisableDenomAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{22}
}
func (m *MsgDisableDenomAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableDenomAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableDenomAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableDenomAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableDenomAdmin.Merge(m, src)
}
func (m *MsgDisableDenomAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableDenomAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableDenomAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableDenomAdmin proto.InternalMessageInfo

func (m *MsgDisableDenomAdmin) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgDisableDenomAdmin) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgDisableDenomAdminResponse struct {
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgDisableDenomAdminResponse) Reset()         { *m = MsgDisableDenomAdminResponse{} }
func (m *MsgDisableDenomAdminResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisableDenomAdminResponse) ProtoMessage()    {}
func (*MsgDisableDenomAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c7e34259da4a559, []int{23}
}
func (m *MsgDisableDenomAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableDenomAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableDenomAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableDenomAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableDenomAdminResponse.Merge(m, src)
}
func (m *MsgDisableDenomAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableDenomAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableDenomAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableDenomAdminResponse proto.InternalMessageInfo

func (m *MsgDisableDenomAdminResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "zigchain.factory.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "zigchain.factory.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgCreateDenom)(nil), "zigchain.factory.MsgCreateDenom")
	proto.RegisterType((*MsgCreateDenomResponse)(nil), "zigchain.factory.MsgCreateDenomResponse")
	proto.RegisterType((*MsgMintAndSendTokens)(nil), "zigchain.factory.MsgMintAndSendTokens")
	proto.RegisterType((*MsgMintAndSendTokensResponse)(nil), "zigchain.factory.MsgMintAndSendTokensResponse")
	proto.RegisterType((*MsgUpdateDenomURI)(nil), "zigchain.factory.MsgUpdateDenomURI")
	proto.RegisterType((*MsgUpdateDenomURIResponse)(nil), "zigchain.factory.MsgUpdateDenomURIResponse")
	proto.RegisterType((*MsgUpdateDenomMintingCap)(nil), "zigchain.factory.MsgUpdateDenomMintingCap")
	proto.RegisterType((*MsgUpdateDenomMintingCapResponse)(nil), "zigchain.factory.MsgUpdateDenomMintingCapResponse")
	proto.RegisterType((*MsgUpdateDenomMetadataAuth)(nil), "zigchain.factory.MsgUpdateDenomMetadataAuth")
	proto.RegisterType((*MsgUpdateDenomMetadataAuthResponse)(nil), "zigchain.factory.MsgUpdateDenomMetadataAuthResponse")
	proto.RegisterType((*MsgBurnTokens)(nil), "zigchain.factory.MsgBurnTokens")
	proto.RegisterType((*MsgBurnTokensResponse)(nil), "zigchain.factory.MsgBurnTokensResponse")
	proto.RegisterType((*MsgSetDenomMetadata)(nil), "zigchain.factory.MsgSetDenomMetadata")
	proto.RegisterType((*MsgSetDenomMetadataResponse)(nil), "zigchain.factory.MsgSetDenomMetadataResponse")
	proto.RegisterType((*MsgWithdrawModuleFees)(nil), "zigchain.factory.MsgWithdrawModuleFees")
	proto.RegisterType((*MsgWithdrawModuleFeesResponse)(nil), "zigchain.factory.MsgWithdrawModuleFeesResponse")
	proto.RegisterType((*MsgProposeDenomAdmin)(nil), "zigchain.factory.MsgProposeDenomAdmin")
	proto.RegisterType((*MsgProposeDenomAdminResponse)(nil), "zigchain.factory.MsgProposeDenomAdminResponse")
	proto.RegisterType((*MsgClaimDenomAdmin)(nil), "zigchain.factory.MsgClaimDenomAdmin")
	proto.RegisterType((*MsgClaimDenomAdminResponse)(nil), "zigchain.factory.MsgClaimDenomAdminResponse")
	proto.RegisterType((*MsgDisableDenomAdmin)(nil), "zigchain.factory.MsgDisableDenomAdmin")
	proto.RegisterType((*MsgDisableDenomAdminResponse)(nil), "zigchain.factory.MsgDisableDenomAdminResponse")
}

func init() { proto.RegisterFile("zigchain/factory/tx.proto", fileDescriptor_3c7e34259da4a559) }

var fileDescriptor_3c7e34259da4a559 = []byte{
	// 1356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0xf9, 0xe5, 0xe7, 0xf4, 0xd7, 0x36, 0x4d, 0x9d, 0x6d, 0xe3, 0x9a, 0x85, 0xd2,
	0x10, 0x5a, 0x9b, 0xa4, 0x2d, 0x55, 0x0b, 0x52, 0x55, 0xa7, 0x42, 0xe4, 0x60, 0xa9, 0xda, 0x10,
	0x28, 0x08, 0xb0, 0xc6, 0xde, 0x61, 0xbd, 0x4a, 0x3c, 0xbb, 0xda, 0x19, 0xb7, 0x0d, 0x15, 0x08,
	0x38, 0x72, 0x40, 0x45, 0x1c, 0xf8, 0x17, 0x38, 0x55, 0x3d, 0xf4, 0xca, 0x81, 0x03, 0x52, 0x8f,
	0x55, 0x4f, 0x88, 0x43, 0x41, 0xed, 0xa1, 0xff, 0x01, 0x67, 0xb4, 0x33, 0xbb, 0xeb, 0xfd, 0x65,
	0xef, 0xa6, 0x22, 0x12, 0x97, 0xd6, 0x33, 0xf3, 0xbd, 0xf7, 0xbd, 0xef, 0x9b, 0xd9, 0xd9, 0xb7,
	0x81, 0xc5, 0x2f, 0x4d, 0xa3, 0xdb, 0x43, 0x26, 0x69, 0x7c, 0x81, 0xba, 0xcc, 0x72, 0x76, 0x1b,
	0xec, 0x4e, 0xdd, 0x76, 0x2c, 0x66, 0xc9, 0x87, 0xfd, 0xa5, 0xba, 0xb7, 0xa4, 0x1c, 0x41, 0x7d,
	0x93, 0x58, 0x0d, 0xfe, 0xaf, 0x00, 0x29, 0xc7, 0xbb, 0x16, 0xed, 0x5b, 0xb4, 0xd1, 0xa7, 0x46,
	0xe3, 0xd6, 0xaa, 0xfb, 0x9f, 0xb7, 0xb0, 0x28, 0x16, 0xda, 0x7c, 0xd4, 0x10, 0x03, 0x6f, 0x69,
	0xde, 0xb0, 0x0c, 0x4b, 0xcc, 0xbb, 0xbf, 0xbc, 0xd9, 0xa5, 0x44, 0x25, 0x36, 0x72, 0x50, 0xdf,
	0x0f, 0xaa, 0x7a, 0x44, 0x1d, 0x44, 0x71, 0xe3, 0xd6, 0x6a, 0x07, 0x33, 0xb4, 0xda, 0xe8, 0x5a,
	0x26, 0x49, 0xac, 0x93, 0xed, 0x60, 0xdd, 0x1d, 0x88, 0x75, 0xf5, 0x57, 0x09, 0x0e, 0xb5, 0xa8,
	0xb1, 0x65, 0xeb, 0x88, 0xe1, 0x1b, 0x3c, 0xb3, 0xfc, 0x36, 0x94, 0xd0, 0x80, 0xf5, 0x2c, 0xc7,
	0x64, 0xbb, 0x15, 0xa9, 0x26, 0x2d, 0x97, 0x9a, 0x95, 0x27, 0x0f, 0xcf, 0xcd, 0x7b, 0xd5, 0x5e,
	0xd3, 0x75, 0x07, 0x53, 0xba, 0xc9, 0x1c, 0x93, 0x18, 0xda, 0x10, 0x2a, 0xbf, 0x03, 0xd3, 0xa2,
	0xb6, 0x4a, 0xa1, 0x26, 0x2d, 0x97, 0xd7, 0x2a, 0xf5, 0xb8, 0x55, 0x75, 0xc1, 0xd0, 0x2c, 0x3d,
	0x7a, 0x7a, 0x6a, 0xe2, 0x97, 0x17, 0x0f, 0x56, 0x24, 0xcd, 0x0b, 0xb9, 0x72, 0xf1, 0xbb, 0x17,
	0x0f, 0x56, 0x86, 0xc9, 0xbe, 0x7f, 0xf1, 0x60, 0x45, 0x0d, 0xa4, 0xdf, 0x09, 0xc4, 0xc7, 0x6a,
	0x55, 0x17, 0xe1, 0x78, 0x6c, 0x4a, 0xc3, 0xd4, 0xb6, 0x08, 0xc5, 0xea, 0xfd, 0x02, 0x1c, 0x6c,
	0x51, 0x63, 0xdd, 0xc1, 0x88, 0xe1, 0xeb, 0x98, 0x58, 0x7d, 0xb9, 0x02, 0x33, 0x5d, 0x77, 0x68,
	0x39, 0x42, 0x97, 0xe6, 0x0f, 0xe5, 0x13, 0x50, 0xa2, 0x83, 0x4e, 0x5b, 0x77, 0x61, 0xbc, 0xfc,
	0x92, 0x36, 0x4b, 0x07, 0x1d, 0x11, 0xb6, 0x09, 0xe5, 0xbe, 0x49, 0x98, 0x49, 0x8c, 0x76, 0x17,
	0xd9, 0x95, 0x22, 0xb7, 0x64, 0xcd, 0xd5, 0xf0, 0xe7, 0xd3, 0x53, 0x0b, 0xc2, 0x16, 0xaa, 0x6f,
	0xd7, 0x4d, 0xab, 0xd1, 0x47, 0xac, 0x57, 0xdf, 0x32, 0x09, 0x7b, 0xf2, 0xf0, 0x5c, 0xd9, 0x33,
	0xcc, 0x1d, 0x0a, 0xb1, 0xe0, 0xa5, 0x59, 0x47, 0xb6, 0x7c, 0x1e, 0x16, 0xba, 0x88, 0xb4, 0xbb,
	0x3d, 0x44, 0x0c, 0xdc, 0x0e, 0xe7, 0x9f, 0xac, 0x49, 0xcb, 0xb3, 0xda, 0xd1, 0x2e, 0x22, 0xeb,
	0x7c, 0xb1, 0x35, 0x0c, 0x3a, 0x0c, 0xc5, 0x2d, 0x6d, 0xa3, 0x32, 0xc5, 0x0b, 0x74, 0x7f, 0xca,
	0x8b, 0x30, 0xbb, 0xa5, 0x6d, 0xb4, 0x7b, 0x88, 0xf6, 0x2a, 0xd3, 0x42, 0xd3, 0x96, 0xb6, 0xf1,
	0x3e, 0xa2, 0x3d, 0xb9, 0x06, 0x65, 0x1d, 0xd3, 0xae, 0x63, 0xda, 0xcc, 0xb4, 0x48, 0x65, 0x86,
	0xaf, 0x86, 0xa7, 0xae, 0xcc, 0xb9, 0xa6, 0xfb, 0x1e, 0xa8, 0xbf, 0x17, 0x60, 0x21, 0x6a, 0x98,
	0xef, 0xe5, 0x18, 0xe3, 0x96, 0x00, 0xdc, 0xe3, 0xd4, 0x46, 0x7a, 0xdf, 0x24, 0x9e, 0x73, 0x25,
	0x77, 0xe6, 0x9a, 0x3b, 0x21, 0x9f, 0x86, 0x83, 0x7d, 0xcc, 0x90, 0x8e, 0x18, 0xf2, 0x20, 0xdc,
	0x3d, 0xed, 0x80, 0x3f, 0x2b, 0x60, 0xf3, 0x30, 0x25, 0xac, 0x9f, 0xe4, 0xab, 0x62, 0x10, 0xf7,
	0x7d, 0x6a, 0x9f, 0x7d, 0x9f, 0xce, 0xf4, 0x7d, 0x26, 0xdd, 0xf7, 0xd9, 0x88, 0xef, 0xea, 0x3d,
	0x09, 0xe6, 0x5b, 0xd4, 0x70, 0xc3, 0xaf, 0x11, 0x7d, 0x13, 0x13, 0xfd, 0x03, 0x6b, 0x1b, 0x13,
	0x2a, 0x2f, 0xc0, 0x34, 0x35, 0x0d, 0x82, 0x7d, 0x13, 0xbd, 0x91, 0x7c, 0x11, 0xa6, 0x98, 0x8b,
	0xf0, 0x9e, 0x9b, 0xc5, 0xba, 0x27, 0xc0, 0x7d, 0xa8, 0xeb, 0xde, 0x43, 0x5b, 0x5f, 0xb7, 0x4c,
	0xd2, 0x9c, 0x74, 0xc5, 0x6b, 0x02, 0x2d, 0x9f, 0x84, 0x92, 0x83, 0xbb, 0xa6, 0x6d, 0x62, 0xc2,
	0x3c, 0x5b, 0x87, 0x13, 0x57, 0xca, 0xee, 0xde, 0x7a, 0x0c, 0xea, 0x3f, 0x12, 0x9c, 0x4c, 0x2b,
	0x29, 0xd8, 0xe0, 0x77, 0x61, 0x8e, 0x27, 0xe5, 0x86, 0x60, 0x9d, 0x17, 0x38, 0xae, 0x12, 0xad,
	0xcc, 0xe1, 0x2d, 0x8e, 0x8e, 0x56, 0x52, 0x88, 0x55, 0x22, 0x72, 0x33, 0xb4, 0xe3, 0xe7, 0x2e,
	0xe6, 0xc8, 0xcd, 0xd0, 0x8e, 0x97, 0x3b, 0x88, 0xa6, 0x03, 0xdb, 0xde, 0xd9, 0xe5, 0x27, 0x24,
	0x47, 0xf4, 0x26, 0x47, 0xab, 0x77, 0xe1, 0x48, 0x70, 0x3f, 0xf0, 0x23, 0xed, 0xee, 0xdd, 0xa8,
	0x7d, 0x08, 0x4e, 0x61, 0x21, 0x7c, 0x0a, 0xbd, 0xbd, 0x2f, 0xa6, 0xef, 0xfd, 0x64, 0x64, 0xef,
	0xa3, 0xae, 0x7f, 0x0e, 0x8b, 0x09, 0xf2, 0xc0, 0xf1, 0x80, 0x4c, 0x4a, 0x21, 0x2b, 0xa4, 0x93,
	0x15, 0xa3, 0x07, 0xed, 0x2f, 0x09, 0x2a, 0x51, 0x82, 0xd0, 0x91, 0xdd, 0x9b, 0xc8, 0xff, 0xcd,
	0x15, 0x17, 0x75, 0xf0, 0x37, 0x09, 0x6a, 0xa3, 0x14, 0x66, 0x38, 0xa9, 0x45, 0x15, 0x71, 0xb5,
	0xcd, 0xd5, 0x4c, 0x45, 0xe0, 0x29, 0xda, 0xd8, 0x9b, 0xa0, 0xe2, 0x48, 0x41, 0xea, 0xd7, 0xa0,
	0xc4, 0x24, 0xf8, 0x57, 0xdf, 0x80, 0xf5, 0xf6, 0xb8, 0x4d, 0xf9, 0xae, 0xd3, 0xa8, 0x87, 0x08,
	0xd4, 0xd1, 0xfc, 0x19, 0x26, 0x26, 0xf9, 0x0a, 0x29, 0x7c, 0xea, 0x36, 0x1c, 0x68, 0x51, 0xa3,
	0x39, 0x70, 0xc8, 0xbe, 0xdc, 0x74, 0x51, 0x3d, 0x9f, 0xc1, 0xb1, 0x08, 0x59, 0x20, 0xe1, 0x3a,
	0x1c, 0x40, 0x7d, 0x6b, 0x40, 0x58, 0xbb, 0x33, 0x70, 0x48, 0x8e, 0x4b, 0xcc, 0x23, 0x99, 0x13,
	0x51, 0x4d, 0x1e, 0xa4, 0xde, 0x85, 0xa3, 0x2d, 0x6a, 0x6c, 0x62, 0x16, 0xf1, 0x6a, 0xa4, 0xa2,
	0xab, 0x30, 0xeb, 0x7b, 0xe1, 0x89, 0x5a, 0x1a, 0xf2, 0x91, 0xed, 0x80, 0xcf, 0x4f, 0xe4, 0x71,
	0x06, 0x41, 0x51, 0x6d, 0x37, 0xe1, 0x44, 0x0a, 0x79, 0xa0, 0xf0, 0x72, 0x88, 0x4c, 0xca, 0x41,
	0x36, 0xa4, 0x51, 0x6f, 0x72, 0xd7, 0x3e, 0x32, 0x59, 0x4f, 0x77, 0xd0, 0xed, 0x96, 0xa5, 0x0f,
	0x76, 0xf0, 0x7b, 0x18, 0x8f, 0xde, 0x2a, 0x05, 0x66, 0x1d, 0xdc, 0xc5, 0xe6, 0x2d, 0xec, 0xf8,
	0x0d, 0x91, 0x3f, 0x8e, 0xd6, 0xfc, 0x83, 0x04, 0x4b, 0xa9, 0xa9, 0x83, 0xb2, 0x5f, 0x82, 0x42,
	0xbe, 0x0c, 0x33, 0x62, 0x5b, 0x68, 0xa5, 0x58, 0x2b, 0xe6, 0xd9, 0x46, 0x1f, 0xaf, 0xfe, 0x58,
	0xe0, 0xef, 0xdf, 0x1b, 0x8e, 0x65, 0x5b, 0x54, 0x1c, 0x79, 0xd1, 0x65, 0xbc, 0x15, 0xad, 0x63,
	0x4c, 0x57, 0x3b, 0xfe, 0x29, 0xbc, 0x14, 0xe9, 0x79, 0x8a, 0x59, 0x1d, 0xf2, 0xb0, 0x1b, 0xba,
	0x9a, 0x78, 0x9c, 0x26, 0x33, 0x82, 0x63, 0x0f, 0xf6, 0xa5, 0x90, 0xf1, 0x6e, 0x8b, 0x7c, 0x26,
	0xbd, 0x45, 0x4e, 0x48, 0x57, 0xef, 0x8b, 0x06, 0x20, 0xb1, 0x90, 0xf1, 0xfc, 0x5f, 0x4a, 0x76,
	0x77, 0x2f, 0xab, 0xb4, 0xb8, 0x27, 0xa5, 0xea, 0x4f, 0x12, 0xc8, 0x6e, 0x33, 0xba, 0x83, 0xcc,
	0xfe, 0x7f, 0xbf, 0x85, 0xe2, 0x73, 0x23, 0x64, 0xe4, 0xe9, 0x74, 0x23, 0x63, 0xf4, 0xea, 0x1a,
	0xbf, 0xcb, 0x63, 0xb3, 0xe3, 0x3d, 0x54, 0x7f, 0x16, 0xed, 0xe0, 0x75, 0x93, 0xa2, 0xce, 0xce,
	0x3e, 0x1c, 0xc7, 0xbc, 0x87, 0x22, 0x51, 0x80, 0x7a, 0x81, 0x9f, 0x89, 0xc4, 0xfc, 0x78, 0x3d,
	0x6b, 0xdf, 0x02, 0x14, 0x5b, 0xd4, 0x90, 0x3f, 0x85, 0xb9, 0xc8, 0x67, 0xe3, 0x2b, 0xc9, 0xcf,
	0xbd, 0xd8, 0xa7, 0x99, 0xf2, 0x46, 0x26, 0x24, 0xe0, 0xfe, 0x18, 0xca, 0xe1, 0x2f, 0xb7, 0x5a,
	0x6a, 0x64, 0x08, 0xa1, 0x2c, 0x67, 0x21, 0x82, 0xd4, 0x3d, 0x38, 0x9c, 0xb8, 0xde, 0x4f, 0xa7,
	0x46, 0xc7, 0x61, 0xca, 0xb9, 0x5c, 0xb0, 0x80, 0xa9, 0x03, 0x07, 0x63, 0xad, 0xe7, 0xab, 0x63,
	0x1c, 0xf0, 0x41, 0xca, 0x9b, 0x39, 0x40, 0x01, 0xc7, 0x6d, 0x38, 0x96, 0xde, 0x00, 0xae, 0x64,
	0x65, 0x19, 0x62, 0x95, 0xb5, 0xfc, 0xd8, 0x80, 0xf8, 0x2b, 0x38, 0x3e, 0xaa, 0xa9, 0x39, 0x9b,
	0x99, 0x2e, 0x84, 0x56, 0x2e, 0xec, 0x05, 0x1d, 0xd0, 0x6f, 0xc3, 0x91, 0xe4, 0x17, 0xd6, 0xeb,
	0xa9, 0xa9, 0x12, 0x38, 0xa5, 0x9e, 0x0f, 0x17, 0x90, 0x7d, 0x08, 0x10, 0xea, 0x6e, 0x4e, 0xa5,
	0x46, 0x0f, 0x01, 0xca, 0x99, 0x0c, 0x40, 0x90, 0x97, 0x80, 0x9c, 0xf2, 0x4a, 0x4e, 0x0f, 0x4f,
	0x02, 0x95, 0x46, 0x4e, 0x60, 0xd8, 0xb4, 0xe4, 0x6b, 0x31, 0xdd, 0xb4, 0x04, 0x6e, 0x84, 0x69,
	0xa3, 0x5f, 0x29, 0x18, 0x0e, 0xc5, 0xaf, 0xef, 0xd7, 0xd2, 0x1f, 0xd2, 0x28, 0x4a, 0x39, 0x9b,
	0x07, 0x15, 0xd6, 0x94, 0xbc, 0x5b, 0xd3, 0x35, 0x25, 0x70, 0x23, 0x34, 0x8d, 0xbc, 0x12, 0x95,
	0xa9, 0x6f, 0xdc, 0x8f, 0x82, 0xe6, 0xda, 0xa3, 0x67, 0x55, 0xe9, 0xf1, 0xb3, 0xaa, 0xf4, 0xf7,
	0xb3, 0xaa, 0x74, 0xef, 0x79, 0x75, 0xe2, 0xf1, 0xf3, 0xea, 0xc4, 0x1f, 0xcf, 0xab, 0x13, 0x9f,
	0x54, 0x52, 0x2e, 0x5f, 0xb6, 0x6b, 0x63, 0xda, 0x99, 0xe6, 0x7f, 0x71, 0x3b, 0xff, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x1e, 0x07, 0xe1, 0x42, 0x5c, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// Create token
	CreateDenom(ctx context.Context, in *MsgCreateDenom, opts ...grpc.CallOption) (*MsgCreateDenomResponse, error)
	// Set the metadata of a denom
	SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error)
	// UpdateDenomURI updates the URI of a denom and its sha256 hash, only bank
	// admin can do it.
	UpdateDenomURI(ctx context.Context, in *MsgUpdateDenomURI, opts ...grpc.CallOption) (*MsgUpdateDenomURIResponse, error)
	// UpdateDenomMintingCap updates the minting cap and options o lock minting
	// cap changes on a denom, only bank admin can do it.
	UpdateDenomMintingCap(ctx context.Context, in *MsgUpdateDenomMintingCap, opts ...grpc.CallOption) (*MsgUpdateDenomMintingCapResponse, error)
	// UpdateDenomMetadataAuth updates the metadata admin of a denom, needed for
	// case when bank admin is disabled
	UpdateDenomMetadataAuth(ctx context.Context, in *MsgUpdateDenomMetadataAuth, opts ...grpc.CallOption) (*MsgUpdateDenomMetadataAuthResponse, error)
	// Mint and send tokens to a recipient
	MintAndSendTokens(ctx context.Context, in *MsgMintAndSendTokens, opts ...grpc.CallOption) (*MsgMintAndSendTokensResponse, error)
	// BurnTokens - Burn tokens from the signer's account, signer has to be bank
	// admin to do it.
	BurnTokens(ctx context.Context, in *MsgBurnTokens, opts ...grpc.CallOption) (*MsgBurnTokensResponse, error)
	WithdrawModuleFees(ctx context.Context, in *MsgWithdrawModuleFees, opts ...grpc.CallOption) (*MsgWithdrawModuleFeesResponse, error)
	// ProposeDenomAdmin represents a message to propose a new denom admin
	ProposeDenomAdmin(ctx context.Context, in *MsgProposeDenomAdmin, opts ...grpc.CallOption) (*MsgProposeDenomAdminResponse, error)
	// ClaimDenomAdmin represents a message to claim the denom admin role
	ClaimDenomAdmin(ctx context.Context, in *MsgClaimDenomAdmin, opts ...grpc.CallOption) (*MsgClaimDenomAdminResponse, error)
	// DisableDenomAdmin represents a message to disable the denom admin role
	DisableDenomAdmin(ctx context.Context, in *MsgDisableDenomAdmin, opts ...grpc.CallOption) (*MsgDisableDenomAdminResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDenom(ctx context.Context, in *MsgCreateDenom, opts ...grpc.CallOption) (*MsgCreateDenomResponse, error) {
	out := new(MsgCreateDenomResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/CreateDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDenomMetadata(ctx context.Context, in *MsgSetDenomMetadata, opts ...grpc.CallOption) (*MsgSetDenomMetadataResponse, error) {
	out := new(MsgSetDenomMetadataResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/SetDenomMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDenomURI(ctx context.Context, in *MsgUpdateDenomURI, opts ...grpc.CallOption) (*MsgUpdateDenomURIResponse, error) {
	out := new(MsgUpdateDenomURIResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/UpdateDenomURI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDenomMintingCap(ctx context.Context, in *MsgUpdateDenomMintingCap, opts ...grpc.CallOption) (*MsgUpdateDenomMintingCapResponse, error) {
	out := new(MsgUpdateDenomMintingCapResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/UpdateDenomMintingCap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDenomMetadataAuth(ctx context.Context, in *MsgUpdateDenomMetadataAuth, opts ...grpc.CallOption) (*MsgUpdateDenomMetadataAuthResponse, error) {
	out := new(MsgUpdateDenomMetadataAuthResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/UpdateDenomMetadataAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintAndSendTokens(ctx context.Context, in *MsgMintAndSendTokens, opts ...grpc.CallOption) (*MsgMintAndSendTokensResponse, error) {
	out := new(MsgMintAndSendTokensResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/MintAndSendTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnTokens(ctx context.Context, in *MsgBurnTokens, opts ...grpc.CallOption) (*MsgBurnTokensResponse, error) {
	out := new(MsgBurnTokensResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/BurnTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawModuleFees(ctx context.Context, in *MsgWithdrawModuleFees, opts ...grpc.CallOption) (*MsgWithdrawModuleFeesResponse, error) {
	out := new(MsgWithdrawModuleFeesResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/WithdrawModuleFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProposeDenomAdmin(ctx context.Context, in *MsgProposeDenomAdmin, opts ...grpc.CallOption) (*MsgProposeDenomAdminResponse, error) {
	out := new(MsgProposeDenomAdminResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/ProposeDenomAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimDenomAdmin(ctx context.Context, in *MsgClaimDenomAdmin, opts ...grpc.CallOption) (*MsgClaimDenomAdminResponse, error) {
	out := new(MsgClaimDenomAdminResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/ClaimDenomAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DisableDenomAdmin(ctx context.Context, in *MsgDisableDenomAdmin, opts ...grpc.CallOption) (*MsgDisableDenomAdminResponse, error) {
	out := new(MsgDisableDenomAdminResponse)
	err := c.cc.Invoke(ctx, "/zigchain.factory.Msg/DisableDenomAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// Create token
	CreateDenom(context.Context, *MsgCreateDenom) (*MsgCreateDenomResponse, error)
	// Set the metadata of a denom
	SetDenomMetadata(context.Context, *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error)
	// UpdateDenomURI updates the URI of a denom and its sha256 hash, only bank
	// admin can do it.
	UpdateDenomURI(context.Context, *MsgUpdateDenomURI) (*MsgUpdateDenomURIResponse, error)
	// UpdateDenomMintingCap updates the minting cap and options o lock minting
	// cap changes on a denom, only bank admin can do it.
	UpdateDenomMintingCap(context.Context, *MsgUpdateDenomMintingCap) (*MsgUpdateDenomMintingCapResponse, error)
	// UpdateDenomMetadataAuth updates the metadata admin of a denom, needed for
	// case when bank admin is disabled
	UpdateDenomMetadataAuth(context.Context, *MsgUpdateDenomMetadataAuth) (*MsgUpdateDenomMetadataAuthResponse, error)
	// Mint and send tokens to a recipient
	MintAndSendTokens(context.Context, *MsgMintAndSendTokens) (*MsgMintAndSendTokensResponse, error)
	// BurnTokens - Burn tokens from the signer's account, signer has to be bank
	// admin to do it.
	BurnTokens(context.Context, *MsgBurnTokens) (*MsgBurnTokensResponse, error)
	WithdrawModuleFees(context.Context, *MsgWithdrawModuleFees) (*MsgWithdrawModuleFeesResponse, error)
	// ProposeDenomAdmin represents a message to propose a new denom admin
	ProposeDenomAdmin(context.Context, *MsgProposeDenomAdmin) (*MsgProposeDenomAdminResponse, error)
	// ClaimDenomAdmin represents a message to claim the denom admin role
	ClaimDenomAdmin(context.Context, *MsgClaimDenomAdmin) (*MsgClaimDenomAdminResponse, error)
	// DisableDenomAdmin represents a message to disable the denom admin role
	DisableDenomAdmin(context.Context, *MsgDisableDenomAdmin) (*MsgDisableDenomAdminResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) CreateDenom(ctx context.Context, req *MsgCreateDenom) (*MsgCreateDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDenom not implemented")
}
func (*UnimplementedMsgServer) SetDenomMetadata(ctx context.Context, req *MsgSetDenomMetadata) (*MsgSetDenomMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDenomMetadata not implemented")
}
func (*UnimplementedMsgServer) UpdateDenomURI(ctx context.Context, req *MsgUpdateDenomURI) (*MsgUpdateDenomURIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDenomURI not implemented")
}
func (*UnimplementedMsgServer) UpdateDenomMintingCap(ctx context.Context, req *MsgUpdateDenomMintingCap) (*MsgUpdateDenomMintingCapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDenomMintingCap not implemented")
}
func (*UnimplementedMsgServer) UpdateDenomMetadataAuth(ctx context.Context, req *MsgUpdateDenomMetadataAuth) (*MsgUpdateDenomMetadataAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDenomMetadataAuth not implemented")
}
func (*UnimplementedMsgServer) MintAndSendTokens(ctx context.Context, req *MsgMintAndSendTokens) (*MsgMintAndSendTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintAndSendTokens not implemented")
}
func (*UnimplementedMsgServer) BurnTokens(ctx context.Context, req *MsgBurnTokens) (*MsgBurnTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnTokens not implemented")
}
func (*UnimplementedMsgServer) WithdrawModuleFees(ctx context.Context, req *MsgWithdrawModuleFees) (*MsgWithdrawModuleFeesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawModuleFees not implemented")
}
func (*UnimplementedMsgServer) ProposeDenomAdmin(ctx context.Context, req *MsgProposeDenomAdmin) (*MsgProposeDenomAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeDenomAdmin not implemented")
}
func (*UnimplementedMsgServer) ClaimDenomAdmin(ctx context.Context, req *MsgClaimDenomAdmin) (*MsgClaimDenomAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimDenomAdmin not implemented")
}
func (*UnimplementedMsgServer) DisableDenomAdmin(ctx context.Context, req *MsgDisableDenomAdmin) (*MsgDisableDenomAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableDenomAdmin not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDenom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/CreateDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDenom(ctx, req.(*MsgCreateDenom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDenomMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDenomMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDenomMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/SetDenomMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDenomMetadata(ctx, req.(*MsgSetDenomMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDenomURI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDenomURI)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDenomURI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/UpdateDenomURI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDenomURI(ctx, req.(*MsgUpdateDenomURI))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDenomMintingCap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDenomMintingCap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDenomMintingCap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/UpdateDenomMintingCap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDenomMintingCap(ctx, req.(*MsgUpdateDenomMintingCap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDenomMetadataAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDenomMetadataAuth)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDenomMetadataAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/UpdateDenomMetadataAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDenomMetadataAuth(ctx, req.(*MsgUpdateDenomMetadataAuth))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintAndSendTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintAndSendTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintAndSendTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/MintAndSendTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintAndSendTokens(ctx, req.(*MsgMintAndSendTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/BurnTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnTokens(ctx, req.(*MsgBurnTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawModuleFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawModuleFees)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawModuleFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/WithdrawModuleFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawModuleFees(ctx, req.(*MsgWithdrawModuleFees))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProposeDenomAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposeDenomAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposeDenomAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/ProposeDenomAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposeDenomAdmin(ctx, req.(*MsgProposeDenomAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimDenomAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimDenomAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimDenomAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/ClaimDenomAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimDenomAdmin(ctx, req.(*MsgClaimDenomAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DisableDenomAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisableDenomAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DisableDenomAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zigchain.factory.Msg/DisableDenomAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DisableDenomAdmin(ctx, req.(*MsgDisableDenomAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "zigchain.factory.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "CreateDenom",
			Handler:    _Msg_CreateDenom_Handler,
		},
		{
			MethodName: "SetDenomMetadata",
			Handler:    _Msg_SetDenomMetadata_Handler,
		},
		{
			MethodName: "UpdateDenomURI",
			Handler:    _Msg_UpdateDenomURI_Handler,
		},
		{
			MethodName: "UpdateDenomMintingCap",
			Handler:    _Msg_UpdateDenomMintingCap_Handler,
		},
		{
			MethodName: "UpdateDenomMetadataAuth",
			Handler:    _Msg_UpdateDenomMetadataAuth_Handler,
		},
		{
			MethodName: "MintAndSendTokens",
			Handler:    _Msg_MintAndSendTokens_Handler,
		},
		{
			MethodName: "BurnTokens",
			Handler:    _Msg_BurnTokens_Handler,
		},
		{
			MethodName: "WithdrawModuleFees",
			Handler:    _Msg_WithdrawModuleFees_Handler,
		},
		{
			MethodName: "ProposeDenomAdmin",
			Handler:    _Msg_ProposeDenomAdmin_Handler,
		},
		{
			MethodName: "ClaimDenomAdmin",
			Handler:    _Msg_ClaimDenomAdmin_Handler,
		},
		{
			MethodName: "DisableDenomAdmin",
			Handler:    _Msg_DisableDenomAdmin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "zigchain/factory/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.URIHash) > 0 {
		i -= len(m.URIHash)
		copy(dAtA[i:], m.URIHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URIHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CanChangeMintingCap {
		i--
		if m.CanChangeMintingCap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MintingCap.Size()
		i -= size
		if _, err := m.MintingCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SubDenom) > 0 {
		i -= len(m.SubDenom)
		copy(dAtA[i:], m.SubDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDenomResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDenomResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDenomResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URIHash) > 0 {
		i -= len(m.URIHash)
		copy(dAtA[i:], m.URIHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URIHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CanChangeMintingCap {
		i--
		if m.CanChangeMintingCap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.MintingCap.Size()
		i -= size
		if _, err := m.MintingCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MetadataAdmin) > 0 {
		i -= len(m.MetadataAdmin)
		copy(dAtA[i:], m.MetadataAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MetadataAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankAdmin) > 0 {
		i -= len(m.BankAdmin)
		copy(dAtA[i:], m.BankAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BankAdmin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintAndSendTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintAndSendTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintAndSendTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintAndSendTokensResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintAndSendTokensResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintAndSendTokensResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSupply != nil {
		{
			size, err := m.TotalSupply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TotalMinted != nil {
		{
			size, err := m.TotalMinted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x12
	}
	if m.TokenMinted != nil {
		{
			size, err := m.TokenMinted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomURI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomURI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomURI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URIHash) > 0 {
		i -= len(m.URIHash)
		copy(dAtA[i:], m.URIHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URIHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomURIResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomURIResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomURIResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URIHash) > 0 {
		i -= len(m.URIHash)
		copy(dAtA[i:], m.URIHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URIHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTx(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomMintingCap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomMintingCap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomMintingCap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanChangeMintingCap {
		i--
		if m.CanChangeMintingCap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MintingCap.Size()
		i -= size
		if _, err := m.MintingCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomMintingCapResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomMintingCapResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomMintingCapResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanChangeMintingCap {
		i--
		if m.CanChangeMintingCap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.MintingCap.Size()
		i -= size
		if _, err := m.MintingCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomMetadataAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomMetadataAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomMetadataAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataAdmin) > 0 {
		i -= len(m.MetadataAdmin)
		copy(dAtA[i:], m.MetadataAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MetadataAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDenomMetadataAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDenomMetadataAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDenomMetadataAuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataAdmin) > 0 {
		i -= len(m.MetadataAdmin)
		copy(dAtA[i:], m.MetadataAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MetadataAdmin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnTokensResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnTokensResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnTokensResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.AmountBurned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetDenomMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDenomMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDenomMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetDenomMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDenomMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDenomMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawModuleFees) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawModuleFees) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawModuleFees) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawModuleFeesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawModuleFeesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawModuleFeesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeDenomAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeDenomAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeDenomAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataAdmin) > 0 {
		i -= len(m.MetadataAdmin)
		copy(dAtA[i:], m.MetadataAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MetadataAdmin)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BankAdmin) > 0 {
		i -= len(m.BankAdmin)
		copy(dAtA[i:], m.BankAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BankAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeDenomAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeDenomAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeDenomAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataAdmin) > 0 {
		i -= len(m.MetadataAdmin)
		copy(dAtA[i:], m.MetadataAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MetadataAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BankAdmin) > 0 {
		i -= len(m.BankAdmin)
		copy(dAtA[i:], m.BankAdmin)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BankAdmin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimDenomAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimDenomAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimDenomAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimDenomAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimDenomAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimDenomAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableDenomAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableDenomAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableDenomAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableDenomAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableDenomAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableDenomAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MintingCap.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.CanChangeMintingCap {
		n += 2
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URIHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateDenomResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BankAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MetadataAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MintingCap.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.CanChangeMintingCap {
		n += 2
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URIHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintAndSendTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Token.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintAndSendTokensResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenMinted != nil {
		l = m.TokenMinted.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TotalMinted != nil {
		l = m.TotalMinted.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TotalSupply != nil {
		l = m.TotalSupply.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDenomURI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URIHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDenomURIResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.URIHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDenomMintingCap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MintingCap.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.CanChangeMintingCap {
		n += 2
	}
	return n
}

func (m *MsgUpdateDenomMintingCapResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MintingCap.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.CanChangeMintingCap {
		n += 2
	}
	return n
}

func (m *MsgUpdateDenomMetadataAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MetadataAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDenomMetadataAuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MetadataAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBurnTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Token.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgBurnTokensResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountBurned.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetDenomMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetDenomMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWithdrawModuleFees) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWithdrawModuleFeesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgProposeDenomAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BankAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MetadataAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProposeDenomAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BankAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MetadataAdmin)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimDenomAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimDenomAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableDenomAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableDenomAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintingCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintingCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeMintingCap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeMintingCap = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDenomResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDenomResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDenomResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintingCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintingCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeMintingCap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeMintingCap = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintAndSendTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintAndSendTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintAndSendTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintAndSendTokensResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintAndSendTokensResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintAndSendTokensResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenMinted == nil {
				m.TokenMinted = &types.Coin{}
			}
			if err := m.TokenMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalMinted == nil {
				m.TotalMinted = &types.Coin{}
			}
			if err := m.TotalMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalSupply == nil {
				m.TotalSupply = &types.Coin{}
			}
			if err := m.TotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomURI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomURI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomURI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomURIResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomURIResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomURIResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomMintingCap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomMintingCap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomMintingCap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintingCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintingCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeMintingCap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeMintingCap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomMintingCapResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomMintingCapResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomMintingCapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintingCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MintingCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanChangeMintingCap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanChangeMintingCap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomMetadataAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomMetadataAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomMetadataAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDenomMetadataAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDenomMetadataAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDenomMetadataAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnTokensResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnTokensResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnTokensResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountBurned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDenomMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDenomMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDenomMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDenomMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDenomMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDenomMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &types1.Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawModuleFees) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawModuleFees: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawModuleFees: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawModuleFeesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawModuleFeesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawModuleFeesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, types.Coin{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeDenomAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeDenomAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeDenomAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeDenomAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeDenomAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeDenomAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BankAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimDenomAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimDenomAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimDenomAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimDenomAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimDenomAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimDenomAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableDenomAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableDenomAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableDenomAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableDenomAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableDenomAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableDenomAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
